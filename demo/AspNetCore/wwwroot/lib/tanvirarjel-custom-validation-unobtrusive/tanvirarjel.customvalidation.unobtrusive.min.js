// Unobtrusive validation support library for TanvirArjel.CustomValidation library
// Copyright (c) TanvirArjel. All rights reserved.
// Licensed under the MIT License, Version 2.0. See License.txt in the project root for license information.
// @version v1.0.0

!function (e) { e.validator.setDefaults({ onfocusout: function (e, t) { 9 === t.which && "" === this.elementValue(e) || this.element(e) } }); var t = function (e) { var t = e.split("-"), a = t[0], r = t[1]; return t[2] + "-" + (["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"].indexOf(r) + 1) + "-" + a }, a = function (e) { return 11 === e.length && (e = t(e)), "Invalid Date" !== new Date(e).toString() && !isNaN(new Date(e)) }, r = function (e) { if (a(e)) { if (/\d{4}-\d{2}-\d{2}/i.test(e)) { return -1 === e.indexOf("T") ? new Date(e + "T00:00:00") : new Date(e) } return 11 === e.length && (e = t(e)), new Date(e) } throw { name: "InvalidDateTimeFormat", message: "Input date/datetime is not in valid format. Please enter the date in valid datetime format. Prefer: '01-Jan-1999' format." } }; e.validator.addMethod("valid-date-format", function (e, r, n) { return !e || (11 === e.length && (date = t(e)), a(e)) }), e.validator.unobtrusive.adapters.add("valid-date-format", [], function (e) { e.rules["valid-date-format"] = {}, e.messages["valid-date-format"] = e.message }), e.validator.addMethod("mindate", function (e, t, a) { if (e) { const t = new Date(a.date); return r(e) >= t } return !0 }), e.validator.unobtrusive.adapters.add("mindate", ["date"], function (e) { e.rules.mindate = e.params, e.messages.mindate = e.message }), e.validator.addMethod("maxdate", function (e, t, a) { if (e) { const t = new Date(a.date); return r(e) <= t } return !0 }), e.validator.unobtrusive.adapters.add("maxdate", ["date"], function (e) { e.rules.maxdate = e.params, e.messages.maxdate = e.message }), e.validator.addMethod("currenttime", function (e, t, a) { if (e) { return new Date > r(e) } return !0 }), e.validator.unobtrusive.adapters.add("currenttime", [], function (e) { e.rules.currenttime = {}, e.messages.currenttime = e.message }), e.validator.addMethod("maxage", function (e, t, a) { if (e) { let t = new Date; return t.setFullYear(t.getFullYear() - a.years), t.setMonth(t.getMonth() - a.months), t.setDate(t.getDate() - a.days), r(e) >= t } return !0 }), e.validator.unobtrusive.adapters.add("maxage", ["years", "months", "days"], function (e) { e.rules.maxage = e.params, e.messages.maxage = e.message }), e.validator.addMethod("minage", function (e, t, a) { if (e) { let t = new Date; return t.setFullYear(t.getFullYear() - a.years), t.setMonth(t.getMonth() - a.months), t.setDate(t.getDate() - a.days), t >= r(e) } return !0 }), e.validator.unobtrusive.adapters.add("minage", ["years", "months", "days"], function (e) { e.rules.minage = e.params, e.messages.minage = e.message }), e.validator.addMethod("filetype", function (e, t, a) { var r = e.split(".").pop(); return -1 !== a.validtypes.toLowerCase().indexOf(r.toLowerCase()) }), e.validator.unobtrusive.adapters.add("filetype", ["validtypes"], function (e) { e.rules.filetype = e.params, e.messages.filetype = e.message }), e.validator.addMethod("file-minsize", function (e, t, a) { if (e && t.files[0]) { var r = a.value; return t.files[0].size / 1024 >= r } return !0 }), e.validator.unobtrusive.adapters.add("file-minsize", ["value"], function (e) { e.rules["file-minsize"] = e.params, e.messages["file-minsize"] = e.message }), e.validator.addMethod("file-maxsize", function (e, t, a) { if (e && t.files[0]) { var r = a.value; return t.files[0].size / 1024 <= r } return !0 }), e.validator.unobtrusive.adapters.add("file-maxsize", ["value"], function (e) { e.rules["file-maxsize"] = e.params, e.messages["file-maxsize"] = e.message }), e.validator.addMethod("input-type-compare", function (t, a, r) { var n = e(a).prop("type"), i = r.property; return n === e(a).closest("form").find('input[name="' + i + '"]').prop("type") }), e.validator.unobtrusive.adapters.add("input-type-compare", ["property"], function (e) { e.rules["input-type-compare"] = e.params, e.messages["input-type-compare"] = e.message }), e.validator.addMethod("comparison-equal", function (t, n, i) { const s = t, o = e(n).prop("type"), u = i.property, d = e(n).closest("form").find('input[name="' + u + '"]'), l = d.prop("type"), m = d.val(); if (s && m) { if ("number" === o && o === l) return Number(t) === Number(d.val()); if ("text" === o && o === l) { if (a(s) && a(m)) { const e = r(s), t = r(m); return e.getTime() === t.getTime() } return s.length === m.length } if (-1 !== o.indexOf("date") && -1 !== l.indexOf("date")) { const e = r(t), a = r(m); return e.getTime() === a.getTime() } if ("time" === o && o == l) return s === m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-equal", ["property"], function (e) { e.rules["comparison-equal"] = e.params, e.messages["comparison-equal"] = e.message }), e.validator.addMethod("comparison-not-equal", function (t, n, i) { const s = t, o = e(n).prop("type"), u = i.property, d = e(n).closest("form").find('input[name="' + u + '"]'), l = d.prop("type"), m = d.val(); if (s && m) { if ("number" === o && o === l) return Number(t) !== Number(d.val()); if ("text" === o && o === l) { if (a(s) && a(m)) { const e = r(s), t = r(m); return e.getTime() !== t.getTime() } return s.length !== m.length } if (-1 !== o.indexOf("date") && -1 !== l.indexOf("date")) { const e = r(t), a = r(m); return e.getTime() !== a.getTime() } if ("time" === o && o == l) return s !== m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-not-equal", ["property"], function (e) { e.rules["comparison-not-equal"] = e.params, e.messages["comparison-not-equal"] = e.message }), e.validator.addMethod("comparison-greater-than", function (t, n, i) { const s = t; let o = e(n).prop("type"); const u = i.property, d = e(n).closest("form").find('input[name="' + u + '"]'), l = d.prop("type"), m = d.val(); if (s && m) { if ("number" === o && o === l) return Number(s) > Number(m); if ("text" === o && o === l) { if (a(s) && a(m)) { return r(s) > r(m) } return s.length > m.length } if (-1 !== o.indexOf("date") && -1 !== l.indexOf("date")) { return r(t) > r(m) } if ("time" === o && o == l) return s > m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-greater-than", ["property"], function (e) { e.rules["comparison-greater-than"] = e.params, e.messages["comparison-greater-than"] = e.message }), e.validator.addMethod("comparison-greater-than-or-equal", function (t, n, i) { const s = t; let o = e(n).prop("type"); const u = i.property, d = e(n).closest("form").find('input[name="' + u + '"]'), l = d.prop("type"), m = d.val(); if (s && m) { if ("number" === o && o === l) return Number(s) >= Number(m); if ("text" === o && o === l) { if (a(s) && a(m)) { return r(s) >= r(m) } return s.length >= m.length } if (-1 !== o.indexOf("date") && -1 !== l.indexOf("date")) { return r(t) >= r(m) } if ("time" === o && o == l) return s >= m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-greater-than-or-equal", ["property"], function (e) { e.rules["comparison-greater-than-or-equal"] = e.params, e.messages["comparison-greater-than-or-equal"] = e.message }), e.validator.addMethod("comparison-smaller-than", function (t, n, i) { const s = t, o = e(n).prop("type"), u = i.property, d = e(n).closest("form").find('input[name="' + u + '"]'), l = d.prop("type"), m = d.val(); if (s && m) { if ("number" === o && o === l) return Number(s) < Number(m); if ("text" === o && o === l) { if (a(s) && a(m)) { return r(s) < r(m) } return s.length < m.length } if (-1 !== o.indexOf("date") && -1 !== l.indexOf("date")) { return r(t) < r(m) } if ("time" === o && o == l) return s < m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-smaller-than", ["property"], function (e) { e.rules["comparison-smaller-than"] = e.params, e.messages["comparison-smaller-than"] = e.message }), e.validator.addMethod("comparison-smaller-than-or-equal", function (t, n, i) { const s = t, o = e(n).prop("type"), u = i.property, d = e(n).closest("form").find('input[name="' + u + '"]'), l = d.prop("type"), m = d.val(); if (s && m) { if ("number" === o && o === l) return Number(s) <= Number(m); if ("text" === o && o === l) { if (a(s) && a(m)) { return r(s) <= r(m) } return s.length <= m.length } if (-1 !== o.indexOf("date") && -1 !== l.indexOf("date")) { return r(t) <= r(m) } if ("time" === o && o == l) return s <= m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-smaller-than-or-equal", ["property"], function (e) { e.rules["comparison-smaller-than-or-equal"] = e.params, e.messages["comparison-smaller-than-or-equal"] = e.message }), e.validator.addMethod("texteditor-required", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "); return " " !== n && n.length > 0 }), e.validator.unobtrusive.adapters.add("texteditor-required", [], function (e) { e.rules["texteditor-required"] = e.params, e.messages["texteditor-required"] = e.message }), e.validator.addMethod("texteditor-minlength", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "), i = r.value; return " " !== n && n.length >= i }), e.validator.unobtrusive.adapters.add("texteditor-minlength", ["value"], function (e) { e.rules["texteditor-minlength"] = e.params, e.messages["texteditor-minlength"] = e.message }), e.validator.addMethod("texteditor-maxlength", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "), i = r.value; return " " !== n && n.length <= i }), e.validator.unobtrusive.adapters.add("texteditor-maxlength", ["value"], function (e) { e.rules["texteditor-maxlength"] = e.params, e.messages["texteditor-maxlength"] = e.message }), e.validator.addMethod("fixed-length", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "), i = r.value; return !n || n.length == i }), e.validator.unobtrusive.adapters.add("fixed-length", ["value"], function (e) { e.rules["fixed-length"] = e.params, e.messages["fixed-length"] = e.message }), e.validator.addMethod("requiredif", function (t, a, n) { const i = n["other-property"], s = n["comparison-type"], o = n["other-property-type"]; let u = n["other-property-value"]; let d = e(a).closest("form").find('input[name="' + i + '"]').val(); if ("number" == o) u = Number(u), d = Number(d); else if ("datetime" == o) u && (u = r(u), "Equal" != s && "NotEqual" != s || (u = u.getTime())), d && (d = r(d), "Equal" != s && "NotEqual" != s || (d = d.getTime())); else if ("string" == o) "Equal" == s || "NotEqual" == s ? (u = u, d = d) : (d = d.length, u = u.length); else { if ("timespan" != o) throw { name: "InvalidTypeException", message: "The type in not supported in requiredif validation." }; u = u, d = d } if ("Equal" == s) { if (d == u) return !!t } else if ("NotEqual" == s) { if (d != u) return !!t } else if ("GreaterThan" == s) { if (d > u) return !!t } else if ("GreaterThanOrEqual" == s) { if (d >= u) return !!t } else if ("SmallerThan" == s) { if (d < u) return !!t } else if ("SmallerThanOrEqual" == s && d <= u) return !!t; return !0 }), e.validator.unobtrusive.adapters.add("requiredif", ["other-property", "comparison-type", "other-property-type", "other-property-value"], function (e) { e.rules.requiredif = e.params, e.messages.requiredif = e.message }) }(jQuery);